<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰«é›·æ¸¸æˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .cell {
            transition: all 0.2s;
        }
        .cell:hover:not(.revealed) {
            background-color: #d1d5db;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4">
    <div class="bg-white rounded-lg shadow-lg p-6 w-auto">        
        <div class="flex justify-between items-center mb-4">
            <div class="flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <span id="timer" class="ml-2 text-lg font-semibold">000</span>
            </div>
            
            <button id="reset" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-full transition duration-300">
                ğŸ˜Š
            </button>
            
            <div class="flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 21v-4m0 0V5a2 2 0 012-2h6.5l1 1H21l-3 6 3 6h-8.5l-1-1H5a2 2 0 00-2 2zm9-13.5V9" />
                </svg>
                <span id="flags" class="ml-2 text-lg font-semibold">10</span>
            </div>
        </div>
        
        <div class="difficulty-selector mb-4 flex justify-center space-x-2">
            <button class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-1 px-3 rounded transition duration-300 text-sm">åˆçº§</button>
            <button class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-1 px-3 rounded transition duration-300 text-sm">ä¸­çº§</button>
            <button class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-1 px-3 rounded transition duration-300 text-sm">é«˜çº§</button>
        </div>
        
        <div id="board" class="grid grid-cols-9 gap-1 mb-4">
            <!-- åŠ¨æ€ç”Ÿæˆçš„æ‰«é›·æ ¼å­å°†åœ¨è¿™é‡Œ -->
            <!-- ç¤ºä¾‹æ ¼å­ -->
            <div class="cell bg-gray-300 hover:bg-gray-400 w-8 h-8 flex items-center justify-center rounded cursor-pointer shadow-sm"></div>
            <div class="cell bg-gray-300 hover:bg-gray-400 w-8 h-8 flex items-center justify-center rounded cursor-pointer shadow-sm"></div>
            <div class="cell bg-gray-300 hover:bg-gray-400 w-8 h-8 flex items-center justify-center rounded cursor-pointer shadow-sm"></div>
            <div class="cell bg-gray-300 hover:bg-gray-400 w-8 h-8 flex items-center justify-center rounded cursor-pointer shadow-sm"></div>
            <div class="cell bg-gray-300 hover:bg-gray-400 w-8 h-8 flex items-center justify-center rounded cursor-pointer shadow-sm"></div>
            <div class="cell bg-gray-300 hover:bg-gray-400 w-8 h-8 flex items-center justify-center rounded cursor-pointer shadow-sm"></div>
            <div class="cell bg-gray-300 hover:bg-gray-400 w-8 h-8 flex items-center justify-center rounded cursor-pointer shadow-sm"></div>
            <div class="cell bg-gray-300 hover:bg-gray-400 w-8 h-8 flex items-center justify-center rounded cursor-pointer shadow-sm"></div>
            <div class="cell bg-gray-300 hover:bg-gray-400 w-8 h-8 flex items-center justify-center rounded cursor-pointer shadow-sm"></div>
            
            <!-- å·²æ­ç¤ºçš„æ ¼å­ç¤ºä¾‹ -->
            <div class="cell revealed bg-gray-200 w-8 h-8 flex items-center justify-center rounded shadow-inner text-blue-600 font-bold">1</div>
            <div class="cell revealed bg-gray-200 w-8 h-8 flex items-center justify-center rounded shadow-inner text-green-600 font-bold">2</div>
            <div class="cell revealed bg-gray-200 w-8 h-8 flex items-center justify-center rounded shadow-inner text-red-600 font-bold">3</div>
            <div class="cell revealed bg-gray-200 w-8 h-8 flex items-center justify-center rounded shadow-inner text-purple-800 font-bold">4</div>
            <div class="cell revealed bg-gray-200 w-8 h-8 flex items-center justify-center rounded shadow-inner text-yellow-700 font-bold">5</div>
            <div class="cell revealed bg-gray-200 w-8 h-8 flex items-center justify-center rounded shadow-inner text-teal-600 font-bold">6</div>
            <div class="cell revealed bg-gray-200 w-8 h-8 flex items-center justify-center rounded shadow-inner text-black font-bold">7</div>
            <div class="cell revealed bg-gray-200 w-8 h-8 flex items-center justify-center rounded shadow-inner text-gray-600 font-bold">8</div>
            <div class="cell revealed bg-gray-200 w-8 h-8 flex items-center justify-center rounded shadow-inner"></div>
            
            <!-- æ ‡è®°ä¸ºæ——å¸œçš„æ ¼å­ -->
            <div class="cell bg-gray-300 w-8 h-8 flex items-center justify-center rounded cursor-pointer shadow-sm text-red-500">ğŸš©</div>
            
            <!-- åœ°é›·æ ¼å­ -->
            <div class="cell revealed bg-red-200 w-8 h-8 flex items-center justify-center rounded shadow-inner">ğŸ’£</div>
        </div>
        
        <div class="text-center text-gray-600 text-sm">
            <p>å·¦é”®ç‚¹å‡»æ­ç¤ºæ ¼å­ï¼Œå³é”®ç‚¹å‡»æ ‡è®°åœ°é›·</p>
            <p class="mt-1">æ¸¸æˆç›®æ ‡ï¼šæ ‡è®°æ‰€æœ‰åœ°é›·å¹¶æ­ç¤ºæ‰€æœ‰å®‰å…¨æ ¼å­</p>
        </div>
    </div>
    
    <!-- ä¿ç•™åŸæœ‰HTMLç»“æ„ -->
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // æ¸¸æˆé…ç½®
            const config = {
                beginner: { rows: 9, cols: 9, mines: 10 },
                intermediate: { rows: 16, cols: 16, mines: 40 },
                expert: { rows: 16, cols: 30, mines: 99 }
            };
            
            // æ¸¸æˆçŠ¶æ€
            let gameState = {
                board: [],
                mineLocations: [],
                revealed: 0,
                flagged: 0,
                gameOver: false,
                gameStarted: false,
                difficulty: 'beginner',
                timer: 0,
                timerInterval: null
            };
            
            // DOM å…ƒç´ 
            const boardElement = document.getElementById('board');
            const resetButton = document.getElementById('reset');
            const timerElement = document.getElementById('timer');
            const flagsElement = document.getElementById('flags');
            const difficultyButtons = document.querySelectorAll('.difficulty-selector button');
            
            // åˆå§‹åŒ–æ¸¸æˆ
            function initGame(difficulty = 'beginner') {
                // æ¸…é™¤ä¹‹å‰çš„æ¸¸æˆçŠ¶æ€
                clearInterval(gameState.timerInterval);
                
                // è®¾ç½®æ–°çš„æ¸¸æˆçŠ¶æ€
                gameState = {
                    board: [],
                    mineLocations: [],
                    revealed: 0,
                    flagged: 0,
                    gameOver: false,
                    gameStarted: false,
                    difficulty: difficulty,
                    timer: 0,
                    timerInterval: null
                };
                
                // æ›´æ–°UI
                resetButton.textContent = 'ğŸ˜Š';
                timerElement.textContent = '000';
                
                const { rows, cols, mines } = config[difficulty];
                flagsElement.textContent = mines;
                
                // åˆ›å»ºæ¸¸æˆæ¿
                createBoard(rows, cols);
                
                // è®¾ç½®åœ°é›·
                setMines(mines, rows, cols);
                
                // è®¡ç®—æ¯ä¸ªæ ¼å­å‘¨å›´çš„åœ°é›·æ•°é‡
                calculateNumbers();
            }
            
            // åˆ›å»ºæ¸¸æˆæ¿
            function createBoard(rows, cols) {
                // æ¸…ç©ºæ¸¸æˆæ¿
                boardElement.innerHTML = '';
                
                // ä½¿ç”¨å†…è”æ ·å¼è®¾ç½®åˆ—æ•°ï¼Œè€Œä¸æ˜¯ä¾èµ–Tailwindçš„åŠ¨æ€ç±»å
                boardElement.style.display = 'grid';
                boardElement.style.gridTemplateColumns = `repeat(${cols}, minmax(0, 1fr))`;
                boardElement.style.gap = '0.25rem';
                boardElement.className = 'mb-4';
                
                // åˆå§‹åŒ–æ¸¸æˆæ¿æ•°ç»„
                gameState.board = Array(rows).fill().map(() => Array(cols).fill(0));
                
                // åˆ›å»ºæ ¼å­
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell bg-gray-300 hover:bg-gray-400 w-8 h-8 flex items-center justify-center rounded cursor-pointer shadow-sm';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                        cell.addEventListener('click', () => handleCellClick(row, col));
                        cell.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            handleRightClick(row, col);
                        });
                        
                        boardElement.appendChild(cell);
                    }
                }
            }
            
            // è®¾ç½®åœ°é›·
            function setMines(mineCount, rows, cols) {
                gameState.mineLocations = [];
                
                while (gameState.mineLocations.length < mineCount) {
                    const row = Math.floor(Math.random() * rows);
                    const col = Math.floor(Math.random() * cols);
                    const key = `${row}-${col}`;
                    
                    if (!gameState.mineLocations.includes(key)) {
                        gameState.mineLocations.push(key);
                        gameState.board[row][col] = -1; // -1 è¡¨ç¤ºåœ°é›·
                    }
                }
            }
            
            // è®¡ç®—æ¯ä¸ªæ ¼å­å‘¨å›´çš„åœ°é›·æ•°é‡
            function calculateNumbers() {
                const { rows, cols } = config[gameState.difficulty];
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        // è·³è¿‡åœ°é›·æ ¼å­
                        if (gameState.board[row][col] === -1) continue;
                        
                        // è®¡ç®—å‘¨å›´çš„åœ°é›·æ•°é‡
                        let count = 0;
                        for (let r = Math.max(0, row - 1); r <= Math.min(rows - 1, row + 1); r++) {
                            for (let c = Math.max(0, col - 1); c <= Math.min(cols - 1, col + 1); c++) {
                                if (gameState.board[r][c] === -1) count++;
                            }
                        }
                        
                        gameState.board[row][col] = count;
                    }
                }
            }
            
            // å¤„ç†æ ¼å­ç‚¹å‡»
            function handleCellClick(row, col) {
                // å¦‚æœæ¸¸æˆç»“æŸæˆ–è€…æ ¼å­å·²ç»è¢«æ­ç¤ºï¼Œåˆ™ä¸åšä»»ä½•æ“ä½œ
                if (gameState.gameOver) return;
                
                const cell = getCellElement(row, col);
                if (cell.classList.contains('revealed') || cell.textContent === 'ğŸš©') return;
                
                // å¼€å§‹æ¸¸æˆè®¡æ—¶
                if (!gameState.gameStarted) {
                    startTimer();
                    gameState.gameStarted = true;
                }
                
                // æ­ç¤ºæ ¼å­
                revealCell(row, col);
            }
            
            // å¤„ç†å³é”®ç‚¹å‡»ï¼ˆæ ‡è®°åœ°é›·ï¼‰
            function handleRightClick(row, col) {
                if (gameState.gameOver) return;
                
                const cell = getCellElement(row, col);
                if (cell.classList.contains('revealed')) return;
                
                // å¼€å§‹æ¸¸æˆè®¡æ—¶
                if (!gameState.gameStarted) {
                    startTimer();
                    gameState.gameStarted = true;
                }
                
                // åˆ‡æ¢æ——å¸œæ ‡è®°
                if (cell.textContent === 'ğŸš©') {
                    cell.textContent = '';
                    gameState.flagged--;
                } else {
                    cell.textContent = 'ğŸš©';
                    cell.classList.add('text-red-500');
                    gameState.flagged++;
                }
                
                // æ›´æ–°å‰©ä½™æ——å¸œæ•°é‡
                const { mines } = config[gameState.difficulty];
                flagsElement.textContent = mines - gameState.flagged;
                
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦èƒœåˆ©
                checkWin();
            }
            
            // æ­ç¤ºæ ¼å­
            function revealCell(row, col) {
                const { rows, cols } = config[gameState.difficulty];
                
                // æ£€æŸ¥è¾¹ç•Œ
                if (row < 0 || row >= rows || col < 0 || col >= cols) return;
                
                const cell = getCellElement(row, col);
                
                // å¦‚æœæ ¼å­å·²ç»è¢«æ­ç¤ºæˆ–æ ‡è®°ä¸ºæ——å¸œï¼Œåˆ™ä¸åšä»»ä½•æ“ä½œ
                if (cell.classList.contains('revealed') || cell.textContent === 'ğŸš©') return;
                
                // æ­ç¤ºæ ¼å­
                cell.classList.add('revealed');
                cell.classList.remove('bg-gray-300', 'hover:bg-gray-400');
                cell.classList.add('bg-gray-200', 'shadow-inner');
                
                // å¦‚æœæ˜¯åœ°é›·ï¼Œæ¸¸æˆç»“æŸ
                if (gameState.board[row][col] === -1) {
                    cell.textContent = 'ğŸ’£';
                    cell.classList.add('bg-red-200');
                    gameOver(false);
                    return;
                }
                
                // å¢åŠ å·²æ­ç¤ºæ ¼å­è®¡æ•°
                gameState.revealed++;
                
                // æ˜¾ç¤ºå‘¨å›´åœ°é›·æ•°é‡
                const mineCount = gameState.board[row][col];
                if (mineCount > 0) {
                    cell.textContent = mineCount;
                    
                    // æ ¹æ®æ•°å­—è®¾ç½®ä¸åŒé¢œè‰²
                    const colors = ['', 'text-blue-600', 'text-green-600', 'text-red-600', 'text-purple-800', 
                                   'text-yellow-700', 'text-teal-600', 'text-black', 'text-gray-600'];
                    cell.classList.add(colors[mineCount], 'font-bold');
                } else {
                    // å¦‚æœå‘¨å›´æ²¡æœ‰åœ°é›·ï¼Œè‡ªåŠ¨æ­ç¤ºå‘¨å›´çš„æ ¼å­
                    for (let r = Math.max(0, row - 1); r <= Math.min(rows - 1, row + 1); r++) {
                        for (let c = Math.max(0, col - 1); c <= Math.min(cols - 1, col + 1); c++) {
                            if (r !== row || c !== col) {
                                revealCell(r, c);
                            }
                        }
                    }
                }
                
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦èƒœåˆ©
                checkWin();
            }
            
            // è·å–æ ¼å­å…ƒç´ 
            function getCellElement(row, col) {
                return document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            }
            
            // æ¸¸æˆç»“æŸ
            function gameOver(isWin) {
                gameState.gameOver = true;
                clearInterval(gameState.timerInterval);
                
                if (isWin) {
                    resetButton.textContent = 'ğŸ˜';
                    // æ ‡è®°æ‰€æœ‰åœ°é›·
                    gameState.mineLocations.forEach(loc => {
                        const [row, col] = loc.split('-').map(Number);
                        const cell = getCellElement(row, col);
                        if (cell.textContent !== 'ğŸš©') {
                            cell.textContent = 'ğŸš©';
                            cell.classList.add('text-red-500');
                        }
                    });
                } else {
                    resetButton.textContent = 'ğŸ˜µ';
                    // æ˜¾ç¤ºæ‰€æœ‰åœ°é›·
                    gameState.mineLocations.forEach(loc => {
                        const [row, col] = loc.split('-').map(Number);
                        const cell = getCellElement(row, col);
                        if (cell.textContent !== 'ğŸš©') {
                            cell.textContent = 'ğŸ’£';
                            cell.classList.add('revealed', 'bg-red-200');
                            cell.classList.remove('bg-gray-300', 'hover:bg-gray-400');
                        }
                    });
                }
            }
            
            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦èƒœåˆ©
            function checkWin() {
                const { rows, cols, mines } = config[gameState.difficulty];
                const totalCells = rows * cols;
                
                // å¦‚æœå·²æ­ç¤ºçš„æ ¼å­æ•°é‡ + åœ°é›·æ•°é‡ = æ€»æ ¼å­æ•°é‡ï¼Œåˆ™æ¸¸æˆèƒœåˆ©
                if (gameState.revealed === totalCells - mines) {
                    gameOver(true);
                }
            }
            
            // å¼€å§‹è®¡æ—¶å™¨
            function startTimer() {
                gameState.timer = 0;
                timerElement.textContent = '000';
                
                gameState.timerInterval = setInterval(() => {
                    gameState.timer++;
                    timerElement.textContent = gameState.timer.toString().padStart(3, '0');
                    
                    // å¦‚æœè®¡æ—¶å™¨è¶…è¿‡999ï¼Œåœæ­¢è®¡æ—¶
                    if (gameState.timer >= 999) {
                        clearInterval(gameState.timerInterval);
                    }
                }, 1000);
            }
            
            // é‡ç½®æ¸¸æˆ
            resetButton.addEventListener('click', function() {
                initGame(gameState.difficulty);
            });
            
            // éš¾åº¦é€‰æ‹©
            difficultyButtons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    const difficulties = ['beginner', 'intermediate', 'expert'];
                    initGame(difficulties[index]);
                });
            });
            
            // åˆå§‹åŒ–æ¸¸æˆ
            initGame();
        });
    </script>
</body>
</html>